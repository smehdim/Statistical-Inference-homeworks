# -*- coding: utf-8 -*-
"""inference_hw1_p10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QmyNToEr0ukWcvneSH1XWHeh0M7El6e0
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Number of data points for each distribution
data_points = 1500

# Distributions to consider
distributions = {
    'Uniform': np.random.uniform(0, 1, data_points),
    'Normal': np.random.normal(0, 1, data_points),
    'Gamma': np.random.gamma(2, 2, data_points),
    'Exponential': np.random.exponential(1, data_points),
    'Binomial': np.random.binomial(10, 0.5, data_points)
}

fig, axs = plt.subplots(5, 3, figsize=(18, 30))

colors_first_part = ['lightblue', 'lightgreen', 'lightcoral', 'lightseagreen', 'lightsalmon']

# Create separate plots for each distribution in the first part
for i, (dist_name, data) in enumerate(distributions.items(), 1):
    sns.histplot(data, kde=True, color=colors_first_part[i - 1], ax=axs[i-1, 0])
    axs[i-1, 0].set_title(f'{dist_name} Distribution')
    sns.boxplot(y=data, color=colors_first_part[i - 1], ax=axs[i-1, 1])
    axs[i-1, 1].set_title(f'{dist_name} Boxplot')
    sns.violinplot(y=data, color=colors_first_part[i - 1], ax=axs[i-1, 2])
    axs[i-1, 2].set_title(f'{dist_name} Violinplot')

plt.tight_layout()

iterations = 1000  # Number of iterations
sample_size = 40  # Size of each sample

sample_means = []

for dist_name, data in distributions.items():
    means = []

    for _ in range(iterations):
        sample = np.random.choice(data, sample_size, replace=True)
        sample_mean = np.mean(sample)
        means.append(sample_mean)

    sample_means.append((dist_name, means))

fig, axs = plt.subplots(5, 3, figsize=(18, 30))

colors_second_part = ['lightpink', 'lightyellow', 'lightblue', 'lightgreen', 'lightcoral']

for i, (dist_name, means) in enumerate(sample_means, 1):
    sns.histplot(means, kde=True, color=colors_second_part[i - 1], ax=axs[i-1, 0])
    axs[i-1, 0].set_title(f'{dist_name} Sample Means Distribution')
    sns.boxplot(y=means, color=colors_second_part[i - 1], ax=axs[i-1, 1])
    axs[i-1, 1].set_title(f'{dist_name} Sample Means Boxplot')
    sns.violinplot(y=means, color=colors_second_part[i - 1], ax=axs[i-1, 2])
    axs[i-1, 2].set_title(f'{dist_name} Sample Means Violinplot')

plt.tight_layout()

plt.show()

import pandas as pd

df = pd.read_csv('/content/drive/MyDrive/datasets/inference/prob10.csv')

df = df.replace('?', np.nan)
from IPython.display import display

summary = pd.DataFrame({
    'Column Name': df.columns,
    'Data Type': df.dtypes.values,
    'Non-null Count': df.count().values,
    'Unique Values': [df[col].nunique() for col in df.columns],
    'Missing Values': df.isnull().sum().values,
})

print(summary)

columns_to_check = ['price','num-of-doors','bore','stroke','horsepower','peak-rpm']  # Specify the columns to consider for NaN values
df = df.dropna(subset=columns_to_check)

categorical_columns = ['make', 'fuel-type','aspiration','num-of-doors','body-style','drive-wheels','engine-location','fuel-system','engine-type','num-of-cylinders']
df[categorical_columns] = df[categorical_columns].astype('category')
float_columns = ['bore','stroke']
df[float_columns] = df[float_columns].astype(float)
int_columns = ['price','horsepower','peak-rpm']
df[int_columns] = df[int_columns].astype(float)
print(df.dtypes)

manufacturer_counts = df['make'].value_counts()
manufacturer_counts.astype(int)

sns.set(style="whitegrid")

plt.figure(figsize=(12, 6))
ax = sns.barplot(x=manufacturer_counts.index, y=manufacturer_counts.values, palette="viridis")
plt.title('Car Manufacturer Frequency', fontsize=16)
plt.xlabel('Manufacturer', fontsize=12)
plt.ylabel('Frequency', fontsize=12)

ax.set_xticklabels(ax.get_xticklabels(), rotation=45, horizontalalignment='right', fontsize=10)

for p in ax.patches:
    ax.annotate(f'{p.get_height()}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=10, color='black', xytext=(0, 5), textcoords='offset points')

most_common_manufacturer = manufacturer_counts.idxmax()
print(f"The manufacturer with the most cars is: {most_common_manufacturer}")

plt.tight_layout()
plt.show()

dispersion = np.std(df)
skewness = df.skew()
kurt = df.kurt(numeric_only=True)

print("Dispersion (Standard Deviation):\n",dispersion)
print("Skewness:\n",skewness)
print("Kurtosis:\n",kurt)

import seaborn as sns
import matplotlib.pyplot as plt

sns.set(style="whitegrid")

plt.figure(figsize=(8, 6))
sns.scatterplot(x="engine-size", y="price", data=df, alpha=0.7)
plt.title("Scatter Plot of Engine Size vs. Price")
plt.xlabel("Engine Size")
plt.ylabel("Price")

plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

sns.set(style="whitegrid", palette="coolwarm")
columns_of_interest = ["engine-size", "price", "horsepower", "curb-weight", "city-mpg"]
g = sns.pairplot(df[columns_of_interest], diag_kind="kde", height=2.5, markers="o")
g.fig.suptitle("Pairplot of Selected Factors", y=1.02)
plt.show()

correlation_matrix = df.corr()
plt.figure(figsize=(13, 10))
sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.25)
plt.title("Correlation Heatmap of Numerical Columns")
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Specify the numerical columns of interest
numerical_columns = ["price", "city-mpg", "peak-rpm"]

fig, axes = plt.subplots(nrows=1, ncols=len(numerical_columns), figsize=(18, 8))

palette = sns.color_palette("hls", len(numerical_columns))

for i, column in enumerate(numerical_columns):
    sns.boxplot(y=df[column], ax=axes[i], color=palette[i], linewidth=2.5)

    # Calculate percentiles, IQR, and whiskers
    quartiles = df[column].quantile([0.25, 0.75])
    q1, q3 = quartiles[0.25], quartiles[0.75]
    iqr = q3 - q1
    lower_whisker = max(df[column].min(), q1 - 1.5 * iqr)
    upper_whisker = min(df[column].max(), q3 + 1.5 * iqr)

    axes[i].set_title(f"{column}\nIQR: {iqr:.2f}\nWhiskers: [{lower_whisker:.2f}, {upper_whisker:.2f}]", fontsize=14)
    axes[i].tick_params(axis='y', labelsize=14)

plt.tight_layout()

plt.show()